#include "common.effect"

uniform float4x4 ViewProj;

uniform texture2d image;
uniform float2 uv_size;

uniform float2 mask_position;
uniform float width;
uniform float height;
uniform float zoom;

uniform float2 aspect_ratio;
uniform float2 global_position;
uniform float global_scale;
uniform float max_corner_radius;
uniform float4 corner_radius;
uniform bool invert;

uniform float min_brightness;
uniform float max_brightness;
uniform float min_contrast;
uniform float max_contrast;
uniform float min_saturation;
uniform float max_saturation;
uniform float min_hue_shift;
uniform float max_hue_shift;

uniform float aa_scale;

sampler_state textureSampler{
    Filter = Linear;
    AddressU = Clamp;
    AddressV = Clamp;
    MinLOD = 0;
    MaxLOD = 0;
};

struct VertData
{
	float4 pos : POSITION;
	float2 uv : TEXCOORD0;
};

float circleAlpha(float2 uv, float r) {
	float d = distance(uv, float2(0.0f, 0.0f));
	float wd = d * aa_scale;
	return smoothstep(r + wd, r - wd, d);
}

float4 applyRoundedCorners(float2 coord, float2 min_vals, float2 max_vals)
{
	//float2 scaled_uv = uv * aspect_ratio;
	float2 min_vals_max = min_vals + max_corner_radius;
	float2 max_vals_max = max_vals - max_corner_radius;
	bool safe_zone = !(coord.x < min_vals_max.x || coord.y < min_vals_max.y || coord.x > max_vals_max.x || coord.y > max_vals_max.y);
	float4 color = pmrgba_to_rgba(image.Sample(textureSampler, coord / uv_size));
	float alpha = color.a;
	
	if (safe_zone) {
		return color;
	}
	float2 local = float2(0.0f, 0.0f);
	float2 tl = min_vals + corner_radius[0];
	float2 tr = float2(max_vals.x, min_vals.y) + float2(-corner_radius[1], corner_radius[1]);
	float2 bl = float2(min_vals.x, max_vals.y) + float2(corner_radius[2], -corner_radius[2]);
	float2 br = max_vals - corner_radius[3];
	
	if (coord.x < tl.x && coord.y < tl.y) {
		local = (coord - tl);
		alpha *= circleAlpha(local, corner_radius[0]);
	} else if (coord.x > tr.x && coord.y < tr.y) {
		local = (coord - tr);
		alpha *= circleAlpha(local, corner_radius[1]);
	} else if (coord.x < bl.x && coord.y > bl.y) {
		local = (coord - bl);
		alpha *= circleAlpha(local, corner_radius[2]);
	} else if (coord.x > br.x && coord.y > br.y) {
		local = (coord - br);
		alpha *= circleAlpha(local, corner_radius[3]);
	}

	return float4(color.rgb, alpha);
}

float4 applyAdjustmentCorners(float2 coord, float2 min_vals, float2 max_vals)
{
	//float2 scaled_uv = uv * aspect_ratio;
	float2 min_vals_max = min_vals + max_corner_radius;
	float2 max_vals_max = max_vals - max_corner_radius;
	bool safe_zone = !(coord.x < min_vals_max.x || coord.y < min_vals_max.y || coord.x > max_vals_max.x || coord.y > max_vals_max.y);
	if (safe_zone)
	{
		return 1.0;
	}
	float alpha = 1.0;
	float2 local = float2(0.0f, 0.0f);
	float2 tl = min_vals + corner_radius[0];
	float2 tr = float2(max_vals.x, min_vals.y) + float2(-corner_radius[1], corner_radius[1]);
	float2 bl = float2(min_vals.x, max_vals.y) + float2(corner_radius[2], -corner_radius[2]);
	float2 br = max_vals - corner_radius[3];
	
	if (coord.x < tl.x && coord.y < tl.y)
	{
		local = (coord - tl);
		alpha *= circleAlpha(local, corner_radius[0]);
	}
	else if (coord.x > tr.x && coord.y < tr.y)
	{
		local = (coord - tr);
		alpha *= circleAlpha(local, corner_radius[1]);
	}
	else if (coord.x < bl.x && coord.y > bl.y)
	{
		local = (coord - bl);
		alpha *= circleAlpha(local, corner_radius[2]);
	}
	else if (coord.x > br.x && coord.y > br.y)
	{
		local = (coord - br);
		alpha *= circleAlpha(local, corner_radius[3]);
	}

	return alpha;
}

float4 applyMask(float2 coord)
{
	float2 dist = coord - mask_position;
	coord = mask_position + (dist / global_scale / zoom);
	float2 crop = float2(width, height) / 2.0 / zoom;

	float2 min_vals = (mask_position - crop);
	float2 max_vals = (mask_position + crop);

	// Must expand out for OpenGL compatibility, rather than using the
	// much more convenient `any`
	bool dont_draw = coord.x < min_vals.x || coord.y < min_vals.y || coord.x > max_vals.x || coord.y > max_vals.y;
	
	return dont_draw ? float4(0.0, 0.0, 0.0, 0.0) : applyRoundedCorners(coord, min_vals, max_vals);
}

float4 applyAdjustments(float2 coord)
{
	float2 crop = float2(width, height) / 2.0 / zoom;
	float2 min_vals = (mask_position - crop);
	float2 max_vals = (mask_position + crop);

	bool outside = coord.x < min_vals.x || coord.y < min_vals.y || coord.x > max_vals.x || coord.y > max_vals.y;
	float scale = outside ? 0.0 : applyAdjustmentCorners(coord, min_vals, max_vals);
	float4 color = pmrgba_to_rgba(image.Sample(textureSampler, coord / uv_size));
	float4 color_adj_min = adjustments(
		color,
		min_brightness,
		min_contrast,
		min_saturation,
		min_hue_shift
	);
	float4 color_adj_max = adjustments(
		color,
		max_brightness,
		max_contrast,
		max_saturation,
		max_hue_shift
	);
	return (color_adj_min * (1.0 - scale) + color_adj_max * scale);
}

VertData mainTransform(VertData v_in)
{
	v_in.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	return v_in;
}

float4 alphaImage(VertData v_in) : TARGET
{
	float2 coord = v_in.uv * uv_size;
	float2 shift = global_position - mask_position;
	float2 coord_p = coord - shift;
	return applyMask(coord_p);
}

float4 adjustmentsImage(VertData v_in) : TARGET
{
	float2 coord = v_in.uv * uv_size;
	return applyAdjustments(coord);
}

technique Alpha
{
	pass
	{
		vertex_shader = mainTransform(v_in);
		pixel_shader = alphaImage(v_in);
	}
}

technique Adjustments
{
	pass
	{
		vertex_shader = mainTransform(v_in);
		pixel_shader = adjustmentsImage(v_in);
	}
}
